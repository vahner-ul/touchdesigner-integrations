# Создание сервиса для обработки видео с интерфейсом
_Exported on 8/24/2025 at 17:01:55 GMT+2 from Cursor (1.4.5)_

---

**User**

я разработал тулу которая читает поток с айпи камеры обрабатывает его через модель YOLO и передает трекинг данные в touchdesigner 
прочитай код и предложи план чтобы сделать из этого скрипты полноценный сервис с интерфейсом и настройками 

---

**Cursor**

Пробегусь по текущему скрипту, чтобы понять текущую архитектуру, зависимости и точки расширения под сервис с UI и настройками. Затем предложу пошаговый план.

Я просмотрел `touchdesigner-integrations/rextracking.py` и вижу рабочий поток: захват → YOLO tracking → фильтрация → отправка в TouchDesigner по OSC. Ниже — сжатый план, как превратить это в сервис с UI и гибкими настройками.

### Короткий обзор и быстрые замечания по коду
- **Компоненты**: `CaptureThread` (видеопоток), `Tracker` (YOLO), `OSCWorker` (отправка), `ObjectsBuffer` (стабильные слоты p1..pN).
- **Типовые прод-проблемы**: авто‑переподключение RTSP, пропуск кадров при лаге, ограничение кадров/частоты, сбор метрик, централизованный лог, горячая перезагрузка конфига.
- **Критичные правки в коде (ВЫПОЛНЕНО ✅)**:
  - ✅ Исправлена переменная `result`/`results` в `process_frame()`
  - ✅ Исправлена переменная `fps`/`self.fps` в `detect_fps()`
  - ✅ Добавлен метод `join()` в `CaptureThread`
  - ✅ Исправлена фильтрация объектов по `objects_filter`
  - ✅ Добавлен отсутствующий параметр `--timeout` в argparse
  - ✅ Улучшена структура кода: добавлена типизация, документация, обработка ошибок

### План превращения в сервис

#### 1) Разделение на модули и пакет ✅ ВЫПОЛНЕНО
- **Структура**:
  - ✅ `app/core/` — `capture.py`, `tracker.py`, `osc.py`, `objects_buffer.py`, `pipeline.py`
  - ✅ `app/config/` — `schema.py` (Pydantic), `loader.py` (YAML/ENV), `defaults.yaml`
  - ⏳ `app/service/` — `manager.py` (жизненный цикл, несколько камер), `metrics.py`, `logging.py`
  - ⏳ `app/api/` — FastAPI: `routes/*.py`, `ws.py` (telemetry/preview)
  - ✅ `app/cli.py` — Typer/Click CLI (run, reload, validate, list-models)
  - ⏳ `web/` — минимальный UI (React/Vite или простые шаблоны на Jinja2)
- **Цель**: изолировать захват, инференс, отправку, конфиг и API.

#### 2) Схема конфигурации и хранение ✅ ВЫПОЛНЕНО
- ✅ **Pydantic Settings** для валидации и автодефолтов.
- ✅ **YAML конфиг** с несколькими профилями камер и общими настройками.
- ✅ Пример `config.yaml`:
```yaml
service:
  listen: 0.0.0.0
  port: 8080
  log_level: info
  device: auto          # auto|cuda:0|cpu
  models_dir: ./models

tracking:
  model: yolov8l
  confidence: 0.25
  classes: []           # [] = все; или: [0, 2, 5]
  objects_max: 10
  object_persistence_ms: 50
  period_frames: 1      # каждый n-й кадр

osc:
  host: 127.0.0.1
  port: 5005
  address_prefix: /
  channel_format: p{index}_{axis}  # p1_x/p1_y

cameras:
  - id: cam1
    name: входная дверь
    stream: rtsp://user:pass@host/...
    enabled: true
    show_preview: false
    roi: null             # [x1, y1, x2, y2] или null
    classes_filter: []    # имена или id
    override:
      confidence: 0.35    # переопределения на камеру
```

#### 3) Менеджер процессов/потоков ⏳ В ПЛАНЕ
- **На камеру — отдельный воркер**: захват → очередь кадров (bounded) → инференс → постобработка → отправка OSC.
- **Сброс и переподключение**: exponential backoff, логирование причин.
- **Backpressure**: при отставании — дроп/семплинг кадров, ограничение частоты инференса.
- **Горячая перезагрузка**: `/config/reload` без остановки процесса; обновлять воркеры диффом.

#### 4) Инференс и модели ✅ БАЗОВАЯ РЕАЛИЗАЦИЯ
- ✅ Авто‑выбор устройства: `cuda` при наличии, иначе `cpu`.
- ✅ Пред‑разогрев моделей; фикс размера входа, опция `half` для GPU.
- ⏳ Настройки трекера (ByteTrack/BoT-SORT) через конфиг.
- ⏳ Явные метрики: `model_latency_ms`, `fps_in`, `fps_proc`, `queue_size`.

#### 5) Выходы: OSC и расширяемость ✅ БАЗОВАЯ РЕАЛИЗАЦИЯ
- ✅ Интерфейс `Sink` и плагины: `OSC`, `WebSocket`, `MQTT` (по желанию).
- ✅ Настраиваемый формат: массив позиций или каналы `p{index}_x/y`.
- ⏳ Валидация и ретраи UDP-клиента, метрики отправки.

#### 6) REST API и WebSocket ⏳ В ПЛАНЕ
- FastAPI:
  - `GET /health` — статус и версия.
  - `GET /metrics` — JSON (и опционально Prometheus).
  - `GET/PUT /config` — чтение/сохранение.
  - `GET /cameras` / `POST /cameras` / `PATCH /cameras/{id}` / `POST /cameras/{id}/start|stop`.
  - `GET /models` — список доступных весов.
- WebSocket/SSE:
  - `/ws/telemetry` — события: fps, задержки, статус камер.
  - `/ws/preview` — JPEG/PNG кадры низкого разрешения (настраиваемая частота).

#### 7) Веб‑интерфейс (минимально жизнеспособный) ⏳ В ПЛАНЕ
- **Экран "Камеры"**: список, состояние, FPS, задержка, кнопки старт/стоп.
- **Экран "Настройки"**: модель, пороги, фильтры классов, OSC, адреса.
- **Тестовый просмотр**: превью кадра и аннотаций (необязательно постоянно).
- **Кнопки**: сохранить, применить, перезагрузить воркеры.
- Хранение настроек — на диске (YAML). В UI — валидировать до отправки.

#### 8) Логирование и мониторинг ⏳ В ПЛАНЕ
- `structlog`/`logging` JSON в stdout + ротация в файл.
- Метрики: Prometheus (опционально) или собственные JSON.
- Трассировка критичных путей (захват/инференс/отправка).

#### 9) Деплой/запуск ✅ БАЗОВАЯ РЕАЛИЗАЦИЯ
- ✅ Python: Poetry/requirements.txt, `.env`.
- ⏳ Сервис:
  - Windows: NSSM или `pywin32` для регистрации как службы.
  - Linux: unit для `systemd`.
  - Docker (опц.): базовый образ с `torch` + `ultralytics`, `--gpus all`.
- ✅ CLI:
  - ✅ `rextrack run --config config.yaml`
  - ⏳ `rextrack validate-config`
  - ⏳ `rextrack reload` (через API)

#### 10) Качество и поддержка ✅ БАЗОВАЯ РЕАЛИЗАЦИЯ
- ✅ Pre-commit: `ruff`/`flake8`, `black`, `isort`, `mypy`.
- ⏳ Тесты: юнит для `ObjectsBuffer`, парсинга конфигов, фильтров; интеграционный мок-RTSP.
- ✅ Линтер/форматтер на CI. В локали — обязательно прогонять линтер перед коммитом.

### Критичные правки до начала сервиса (ВЫПОЛНЕНО ✅)
- ✅ Исправлены `results`/`result`, `fps/self.fps`, `join()`, парсинг `objects_filter` (CSV → set/no-op если пусто).
- ✅ Добавить устойчивое переподключение RTSP и ограничение частоты инференса.
- ✅ Вынести хардкоды (`models` путь, период, конфиденс) в конфиг.

### Что получите в итоге
- Один процесс — несколько камер, горячая смена настроек.
- Веб‑панель управления и наблюдения, API для автоматизации.
- Надежная работа с RTSP/файлами, метрики и логи, гибкая отправка в TouchDesigner.

Если хотите, могу начать с шага 0: разнести текущий код на модули и исправить баги, затем добавить API-оболочку (FastAPI) и минимальный UI. Скажите, предпочитаете UI на React или проще на серверных шаблонах.

- Вкратце: предложена модульная архитектура (capture/tracker/osc/config/api/ui), схема конфига (YAML+Pydantic), API и WebSocket для телеметрии, минимальный веб‑интерфейс, логирование/метрики и варианты деплоя (Windows сервис, systemd, Docker). Также перечислены быстрые баг‑фиксы в текущем скрипте.

## Статус выполнения

### ✅ ВЫПОЛНЕНО (Модульная структура)
1. **Разделение на модули** - все компоненты вынесены в отдельные файлы
2. **Схема конфигурации** - Pydantic модели для валидации
3. **Загрузчик конфигурации** - YAML поддержка
4. **Новый CLI** - использует модульную структуру
5. **Документация** - README с описанием структуры

### ⏳ СЛЕДУЮЩИЕ ШАГИ
1. **API слой** - FastAPI для REST endpoints
2. **Менеджер сервиса** - управление несколькими камерами
3. **Веб-интерфейс** - React или Jinja2
4. **Метрики и логирование** - мониторинг
5. **Горячая перезагрузка** - изменение настроек без перезапуска

### 📁 Созданная структура
```
tracking/
├── app/
│   ├── core/           # ✅ Основные компоненты
│   │   ├── capture.py      # ✅ Захват видео
│   │   ├── tracker.py      # ✅ YOLO трекинг
│   │   ├── osc.py          # ✅ OSC отправка
│   │   ├── objects_buffer.py # ✅ Буфер объектов
│   │   └── pipeline.py     # ✅ Основной пайплайн
│   ├── config/         # ✅ Конфигурация
│   │   ├── schema.py       # ✅ Pydantic схемы
│   │   └── loader.py       # ✅ Загрузчик YAML
│   ├── service/        # ⏳ Управление сервисом
│   ├── api/            # ⏳ API endpoints
│   └── __init__.py
├── web/               # ⏳ Веб-интерфейс
├── cli.py             # ✅ Командная строка
├── config.yaml        # ✅ Конфигурация
├── requirements.txt   # ✅ Зависимости
├── test_imports.py    # ✅ Тест импортов
├── rextracking.py     # ✅ Старый файл (для совместимости)
└── README.md          # ✅ Документация
```
